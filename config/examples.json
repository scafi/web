[{"groupName":"Basic","examples":[{"name":"Hello scafi","body":"\"hello scafi\"","devices":{"sensors":{"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]},"source":false,"obstacle":false,"target":false}}},{"name":"Sum of fields","body":"1 + 2","devices":{"sensors":{"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]}}}},{"name":"Tuple field","body":"(10, 20)","devices":{"sensors":{"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]}}}},{"name":"Random","body":"import scala.util.Random\nRandom.nextInt(100)\n","devices":{"sensors":{"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]}}}},{"name":"Device id field","body":"mid","devices":{"sensors":{"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]}}}},{"name":"Sense","body":"sense[Boolean](\"sensor\")","devices":{"sensors":{"sensor":false,"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]}}}},{"name":"Mux and sense","body":"mux(sense[Boolean](\"sensor1\") && sense[Boolean](\"sensor2\")) {\n  \"hot\"\n} /*else*/ {\n  \"cold\"\n}","devices":{"sensors":{"sensor1":true,"sensor2":true,"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]}}}},{"name":"Neighbour count","body":"foldhoodPlus(0)((a,b) => a + b)(nbr(1))","devices":{"sensors":{"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]}}}},{"name":"Field Evolution","body":"rep(0){ _ + 1 }","devices":{"sensors":{"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]}}}},{"name":"Branching ","body":"branch(sense[Boolean](\"sensor\")) {\n  foldhood(0)((a,b) => a + b)(nbr(1))\n} {\n  0\n}","devices":{"sensors":{"sensor":false,"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]}}}},{"name":"Neighbour range field","body":"//using StandardSensors\n(minHood{nbrRange}, f\"${minHoodPlus{nbrRange}}%.2g\")\n","devices":{"sensors":{"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]}}}},{"name":"Function reuse","body":"def sense1() = sense[Boolean](\"sensor\")\nfoldhood(0)(_+_)(if(nbr{sense1}) 1 else 0)","devices":{"sensors":{"sensor":false,"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]}}}},{"name":"Gradient","body":"//using StandardSensors, Actuation\nval gradient = rep(Double.PositiveInfinity)(distance =>\n  mux(sense[Boolean](\"sensor\")){\n    0.0\n  }{\n    minHoodPlus(nbr{distance} + nbrRange)\n  }\n)\nval maxValue = 500.0\nval hueColor = 0\nval saturation = if(gradient.isInfinite) { 0 } else { gradient / maxValue }\nval color = hsl(hueColor,1 - saturation, 0.5)\n(gradient.formatted(\"%4.2f\"), ledAll to color)","devices":{"sensors":{"sensor":false,"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]}},"initialValues":{"1":{"sensor":true}}}}]},{"groupName":"Libraries","examples":[{"name":"Spread across the gradient","body":"//using StandardSensors, BlockG\nG2(sense[Boolean](\"source\"))(0.0)(_ + nbrRange())(nbrRange)","devices":{"sensors":{"source":false,"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]}}}},{"name":"Broadcast data","body":"//using StandardSensors, BlockG\nbroadcast(sense[Boolean](\"source\"), mid())","devices":{"sensors":{"source":false,"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]}}}},{"name":"Channel","body":"//using StandardSensors, BlockG, Actuation\ndef source : Boolean = sense(\"source\")\ndef target : Boolean = sense(\"target\")\ndef channel(source: Boolean, target: Boolean, width: Double): Boolean = {\n  distanceTo(source) + distanceTo(target) <= distanceBetween(source, target) + width\n}\nval channelWidth = 1\nval inChannel = channel(source, target, channelWidth)\nval channelColor = mux(inChannel) { ledAll to \"white\" } { ledAll to off }\nval nodeColor = mux(source) { ledAll to \"blue\" } {\n  mux(target) { ledAll to \"green\" } { channelColor }\n}\n\n(inChannel, nodeColor)","devices":{"sensors":{"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]},"source":false,"obstacle":false,"target":false},"initialValues":{"1":{"source":true},"100":{"target":true}}}},{"name":"Channel with obstacles","body":"//using StandardSensors, BlockG, Actuation\ndef obstacle : Boolean = sense(\"obstacle\")\ndef source : Boolean = sense(\"source\")\ndef target : Boolean = sense(\"target\")\ndef channel(source: Boolean, target: Boolean, width: Double): Boolean = {\n  distanceTo(source) + distanceTo(target) <= distanceBetween(source, target) + width\n}\nval channelWidth = 1\n\nval inChannel = branch(obstacle){ false }{ channel(source, target, channelWidth) }\nval channelColor = mux(inChannel) { ledAll to \"white\" } { ledAll to off }\nval nodeColor = mux(source) { ledAll to \"blue\" } {\n  mux(target) { ledAll to \"green\" } {\n    mux(obstacle) {ledAll to \"red\" } { channelColor }\n  }\n}\n\n(inChannel, nodeColor)","devices":{"sensors":{"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]},"source":false,"obstacle":false,"target":false},"initialValues":{"100":{"target":true},"40":{"obstacle":true},"44":{"obstacle":true},"43":{"obstacle":true},"1":{"source":true},"42":{"obstacle":true},"41":{"obstacle":true}}}},{"name":"Collect data","body":"//using StandardSensors, BlockG, BlockC\nimport scala.util.Random\nval baseline = 10\ndef temperature : Double = Random.nextInt(20) + baseline\ndef source : Boolean = sense(\"source\")\nval potential = distanceTo(source)\nval totalTemperature = C[Double,Double](potential, _+_, temperature, 0)\nval count = C[Double, Double](potential, _ + _, 1.0, 0)\nval avg = totalTemperature / count\nmux[Any](source) { avg } { \"\" }","devices":{"sensors":{"source":false,"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]}}}},{"name":"Collect and spread data","body":"//using StandardSensors, BlockG, BlockC\nimport scala.util.Random\nval baseline = 10\nval danger = 20\ndef temperature : Double = Random.nextInt(20) + baseline\ndef source : Boolean = sense(\"source\")\nval potential = distanceTo(source)\nval totalTemperature = C[Double,Double](potential, _+_, temperature, 0)\nval count = C[Double, Double](potential, _ + _, 1.0, 0)\nval avg = totalTemperature / count\nval state = mux(avg > danger) { \"danger\" } { \"ok\" }\nbroadcast(source, state)","devices":{"sensors":{"source":false,"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]}}}},{"name":"Block S","body":"// using BlockS, StandardSensors, Actuation\nval area = 200\nval leader = S(area, nbrRange)\n(leader, mux(leader) { ledAll to \"red\" } { ledAll to \"white\" })","devices":{"sensors":{"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]}}}}]},{"groupName":"Matrix led","examples":[{"name":"Turn on matrix with colors","body":"//using Actuation\nmux(mid().toInt < 50) { ledAll to \"green\" } { ledAll to \"#FF00FF\" }","devices":{"sensors":{"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]}}}},{"name":"Hsl colors","body":"//using Actuation\nval colors = 50\nval color = rep(0)(c => (c + 1) % colors)\nledAll to hsl(color / colors.toDouble, 0.5, 0.5)","devices":{"sensors":{"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]}}}},{"name":"Color single led","body":"//using Actuation\nval firstRow = Seq(led(0,0) to \"white\", led(0,1) to \"red\", led(0,2) to \"green\")\nval secondRow = Seq(led(1,0) to \"#FF11AA\", led(1,1) to \"#F2F1A2\", led(1,2) to \"#F2AAAA\")\nval thirdRow = Seq(led(2,0) to hsl(0.9, 0.5, 0.5), led(2,1) to hsl(0.3, 0.5, 0.5), led(2,2) to hsl(0.2, 0.5, 0.5))\nfirstRow ++ secondRow ++ thirdRow","devices":{"sensors":{"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]}}}},{"name":"Shortcuts","body":"//using Actuation\nval id = mid().toInt\nif (id < 10) {\n  ledX to \"red\"\n} else if (id < 20) {\n  ledD to \"white\"\n} else if (id < 30) {\n  ledAD to \"yellow\"\n} else if (id < 40) {\n  ledCol(0) to hsl(0.2, 0.5, 0.5)\n} else if (id < 50) {\n  ledRow(1) to \"green\"\n} else {\n  ledAll to \"cyan\"\n}","devices":{"sensors":{"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]}}}},{"name":"Sensor based colors","body":"//using Actuation\nval sourceColor = mux(sense(\"source\")) { \"red\" } { \"white\" }\nval obstacleColor = mux(sense(\"obstacle\")) { \"green\" } { \"white\" }\nval targetColor = mux(sense(\"target\")) { \"yellow\" } { \"white\" }\n(ledCol(0) to sourceColor, ledCol(1) to obstacleColor, ledCol(2) to targetColor)","devices":{"sensors":{"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]},"source":false,"obstacle":false,"target":false}}},{"name":"complex shape","body":"//using Actuation\nval eyes = Seq(ledAll to \"white\", led(1,1) to off, led(1,3) to off)\nval mouth = Seq(led(3,0) to off, led(3, 4) to off, led(4,1) to off, led(4,2) to off, led(4,3) to off)\neyes ++ mouth","devices":{"sensors":{"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":5,"pixels":[[[0,2],"#ffffff"],[[0,0],"#ffffff"],[[4,0],"#ffffff"],[[3,4],"#ffffff"],[[3,1],"#ffffff"],[[4,1],"#ffffff"],[[2,0],"#ffffff"],[[0,3],"#ffffff"],[[4,4],"#ffffff"],[[3,0],"#ffffff"],[[1,1],"#ffffff"],[[1,4],"#ffffff"],[[0,4],"#ffffff"],[[3,2],"#ffffff"],[[1,3],"#ffffff"],[[2,2],"#ffffff"],[[4,2],"#ffffff"],[[2,4],"#ffffff"],[[0,1],"#ffffff"],[[3,3],"#ffffff"],[[2,3],"#ffffff"],[[1,2],"#ffffff"],[[2,1],"#ffffff"],[[4,3],"#ffffff"],[[1,0],"#ffffff"]]}}}}]},{"groupName":"Movement","examples":[{"name":"Change velocity","body":"//using Actuation\nmux(mid().toInt < 50) { velocity set Cartesian(1, 0) } { velocity set Polar(2, Math.PI) }","devices":{"sensors":{"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]}}}},{"name":"Absolute movement","body":"//using Actuation\nposition set (50, 50)","devices":{"sensors":{"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]}}}},{"name":"Movement with rep","body":"//using Actuation\nval angle = rep(0.0)(v => v + 0.1)\nvelocity set Polar(1, angle)","devices":{"sensors":{"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]}}}},{"name":"Movement 2D lib: rotation","body":"//using Actuation, Movement2D, StandardSensors\nval direction = mux(sense(\"source\")) { clockwiseRotation(100.0, 100.0) } { anticlockwiseRotation(100.0, 100.0) }\nvelocity set direction","devices":{"sensors":{"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]},"source":false,"obstacle":false,"target":false}}},{"name":"Movement 2D lib: go to","body":"//using Actuation, Movement2D, StandardSensors\nvelocity set goToPoint(100, 100)","devices":{"sensors":{"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]}}}},{"name":"Movement 2D lib: explore","body":"//using Actuation, Movement2D, StandardSensors\n//val zone = CircularZone(center = (100.0, 100.0), radius = 500.0)\nval zone = RectangularZone(center = (0.0, 0.0), width = 600, height = 600)\nval trajectoryTime = 100\nval reachGoalThr = 10.0\nvelocity set explore(zone, trajectoryTime, reachGoalThr)","devices":{"sensors":{"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]}}}},{"name":"Flock lib: basic","body":"//using Actuation, FlockLib, StandardSensors\nval flockVelocity = FlockBehaviour(\n    attractionForce = 0.001,\n    alignmentForce = 0.1,\n    repulsionForce = 0.5,\n    separationDistance = 10.0,\n).run()\nvelocity set flockVelocity","devices":{"sensors":{"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]}}}},{"name":"Flock lib: with separation","body":"//using Actuation, FlockLib, AdvancedFlock, Movement2D, StandardSensors\nval weigth = 0.5\nval separation = 30.0\nvelocity set withSeparation(goToPoint(0, 0) * weigth)(separation)\n","devices":{"sensors":{"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]}}}},{"name":"Flock lib: advanced","body":"//using Actuation, FlockLib, AdvancedFlock, Movement2D, StandardSensors\n\n/*\n  This example shows how to add behaviour to a standard flock behaviour. Check what happens if you enable sense2 in a part of the space.\n  To enable sense2 you should select nodes and then click the number 2.\n */\n\nval rotationWeight = 0.1\nval goalWeight = 0.3\nval obstacleWeight = 0.5\nval target = (1000.0, 1000.0)\ndef obstacle : Boolean = sense(\"obstacle\")\nval flockVelocity = FlockBehaviour()\n  .addBehaviour(anticlockwiseRotation(target) * rotationWeight) // via pimping AdvancedFlock, this tend to rotate toward the goal\n  .withGoal(target, goalWeight) //this move the aggregate toward the target\n  .withObstacleAvoid(obstacle, obstacleWeight) //this avoid a part of the computational field.\n  .run()\nvelocity set flockVelocity","devices":{"sensors":{"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]},"source":false,"obstacle":false,"target":false}}}]},{"groupName":"High level","examples":[{"name":"Pattern SCR","body":"//using StandardSensors, BlockG, BlockC, BlockS, StateManagement\ntrait Heater {\n  def temp : Double\n  def turnOn : Unit\n  def turnOff : Unit\n}\ncase class FakeHeater(baseline : Double) extends Heater {\n  private var _temp = baseline\n  private var on : Boolean = false\n\n  override def temp: Double = {\n    _temp += (if(on) { 0.1 } else { -0.1 })\n    _temp\n  }\n  def turnOn : Unit = on = true\n  def turnOff : Unit = on = false\n}\n//aggregate code\nval baseline = 20\nval toCold = 12\nval toHot = 25\nval heater = remember(FakeHeater(baseline))\nval area = 200\nval leader = S(area, nbrRange)\nval potential = distanceTo(leader, nbrRange)\nval count = C[Double, Double](potential, _ + _, 1.0, 0.0)\nval temperature = C[Double, Double](potential, _ + _, heater.temp, 0.0)\nval avg = temperature / count\nval action : Heater => String = if(avg < toCold) {\n  \th => {\n      h.turnOn\n      \"turn on\"\n    }\n} else if (avg > toHot) {\n\th => {\n      h.turnOff\n      \"turn off\"\n    }\n} else {\n\th => \"ok..\"\n}\nval workerAction = broadcast(leader, action)\nbranch(leader) { \"leader\" } { action(heater) }\n","devices":{"sensors":{"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]}}}},{"name":"Pattern SCR building areas","body":"//using StandardSensors, Actuation, BlockG, BlockS\ndef remap(min: Double, max: Double,\n          newMin: Double, newMax: Double, x: Double): Double = {\n  val nx = if(x < min) min else if(x > max) max else x\n  (nx-min)/(max-min) * (newMax-newMin) + newMin\n}\nval radius = 500\ndef mapToHex(x: Double) = remap(0, radius, 255, 16, x).toLong.toHexString\n\nval leader = S(radius, nbrRange)\nval distance = distanceTo(leader)\nval ledColor = mux(leader) { \"red\" } { s\"#0000${mapToHex(distance)}\" }\nledAll to ledColor\n","devices":{"sensors":{"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]}}}},{"name":"Pattern SCR with movement","body":"//using StandardSensors, Actuation, Movement2D, FlockLib, AdvancedFlock, BlockC, BlockG, BlockT, BlockS\n/*\n  This example shows how to elect a leader and then stay near him. It is possible using the S block,\n  that allows to divide the space into zones and to elect a leader.\n  The result shows the creation of agglomerates near a node.\n */\nval radius = 200\nval separationDistance = 30.0\nval leader = S(radius, nbrRange)\nval leaderPosition = broadcast(leader, currentPosition())\nval ledColor = mux(leader) { \"red\" } { \"#000000\" }\nval direction = withSeparation(goToPoint(leaderPosition.x, leaderPosition.y))(separationDistance)\n(ledAll to ledColor, velocity set direction, leader)\n","devices":{"sensors":{"matrix":{"$type":"it.unibo.scafi.js.model.MatrixLed.MatrixMap","dimension":3,"pixels":[[[0,2],"#bb86fc"],[[0,0],"#bb86fc"],[[2,0],"#bb86fc"],[[1,1],"#bb86fc"],[[2,2],"#bb86fc"],[[0,1],"#bb86fc"],[[1,2],"#bb86fc"],[[2,1],"#bb86fc"],[[1,0],"#bb86fc"]]},"source":false,"obstacle":false,"target":false}}}]}]
